<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

<span id='Deft-mixin-Observer'>/**
</span>* A mixin that marks a class as an observer of events from Observable objects.
* Classes using the mixin should call the mixed-in method 'createObservers()' to
* trigger creation of the event listeners using the 'observe:' configuration.
* The Deft JS ViewController uses this mixin, adding the Observers at construction
* and removing them on ViewController destruction.
*
* **IMPORTANT NOTE:** If you choose to use this mixin in your own classes, and you intend
* to destroy the instance, you **MUST** call the mixed-in method 'removeObservers()' at
* destruction time! Failure to do this will result in memory leaks, since the event
* listeners will not be cleaned up. There is no standard way for this mixin to be notified
* of pending instance destruction, so the developer must ensure that this is done.
*/

Ext.define('Deft.mixin.Observer', {
  requires: ['Deft.log.Logger', 'Deft.util.DeftMixinUtils'],
<span id='Deft-mixin-Observer-method-onClassMixedIn'>  /**
</span>  	@private
  */

  onClassMixedIn: function(target) {
    target.override({
      constructor: Deft.mixin.Observer.createMixinInterceptor()
    });
    target.onExtended(function(clazz, config) {
      clazz.override({
        constructor: Deft.mixin.Observer.createMixinInterceptor()
      });
      return true;
    });
  },
<span id='Deft-mixin-Observer-method-createObservers'>  /**
</span>  	* @protected
  */

  createObservers: function() {
    var events, target, _ref;
    this.removeObservers();
    this.registeredObservers = {};
    _ref = this.observe;
    for (target in _ref) {
      events = _ref[target];
      this.addObserver(target, events);
    }
  },
<span id='Deft-mixin-Observer-method-addObserver'>  /**
</span>  	* @protected
  */

  addObserver: function(target, events) {
    var observer;
    observer = Ext.create('Deft.mvc.Observer', {
      host: this,
      target: target,
      events: events
    });
    this.registeredObservers[target] = observer;
  },
<span id='Deft-mixin-Observer-method-removeObservers'>  /**
</span>  	* @protected
  */

  removeObservers: function() {
    var observer, target, _ref;
    _ref = this.registeredObservers;
    for (target in _ref) {
      observer = _ref[target];
      observer.destroy();
      delete this.registeredObservers[target];
    }
  },
  statics: {
<span id='Deft-mixin-Observer-static-property-MIXIN_COMPLETED_KEY'>    MIXIN_COMPLETED_KEY: &quot;$observing&quot;,
</span><span id='Deft-mixin-Observer-static-property-PROPERTY_NAME'>    PROPERTY_NAME: &quot;observe&quot;,
</span><span id='Deft-mixin-Observer-static-method-createMixinInterceptor'>    /**
</span>    		* @private
    */

    createMixinInterceptor: function() {
      return function(config) {
        var mixinCompletedKey, propertyName;
        if (config == null) {
          config = {};
        }
        mixinCompletedKey = Deft.mixin.Observer.MIXIN_COMPLETED_KEY;
        propertyName = Deft.mixin.Observer.PROPERTY_NAME;
        if (this[propertyName] == null) {
          this[propertyName] = {};
        }
        if (!this[mixinCompletedKey] &amp;&amp; Ext.Object.getSize(this[propertyName]) &gt; 0) {
          Deft.util.DeftMixinUtils.mergeSuperclassProperty(this, propertyName, Deft.mixin.Observer.propertyMergeHandler);
          Deft.mixin.Observer.afterMixinProcessed(this);
          this[Deft.util.DeftMixinUtils.parentConstructorForVersion(this)](arguments);
          return this;
        }
        return this[Deft.util.DeftMixinUtils.parentConstructorForVersion(this)](arguments);
      };
    },
<span id='Deft-mixin-Observer-static-method-propertyMergeHandler'>    /**
</span>    		* @private
    		* Called by DeftMixinUtils.mergeSuperclassProperty(). Allows each mixin to define its own
    		* customized subclass/superclass merge logic.
    		*
    		* Merges child and parent observers into a single object. This differs from a normal object merge because
    		* a given observer target and event can potentially have multiple handlers declared in different parent or
    		* child classes. It transforms an event handler value into an array of values, and merges the arrays of handlers
    		* from child to parent. This maintains the handlers even if both parent and child classes have handlers for the
    		* same target and event.
    */

    propertyMergeHandler: function(originalParentObserve, originalChildObserve) {
      var childEvent, childEvents, childHandler, childHandlerArray, childObserve, childTarget, eventOptionNames, parentEvent, parentEvents, parentHandler, parentHandlerArray, parentObserve, parentTarget, _ref, _ref1;
      if (!Ext.isObject(originalParentObserve)) {
        parentObserve = {};
      } else {
        parentObserve = Ext.clone(originalParentObserve);
      }
      if (!Ext.isObject(originalChildObserve)) {
        childObserve = {};
      } else {
        childObserve = Ext.clone(originalChildObserve);
      }
      eventOptionNames = [&quot;buffer&quot;, &quot;single&quot;, &quot;delay&quot;, &quot;element&quot;, &quot;target&quot;, &quot;destroyable&quot;];
      Deft.mixin.Observer.convertConfigArray(parentObserve, eventOptionNames);
      Deft.mixin.Observer.convertConfigArray(childObserve, eventOptionNames);
      for (childTarget in childObserve) {
        childEvents = childObserve[childTarget];
        for (childEvent in childEvents) {
          childHandler = childEvents[childEvent];
          if (Ext.isString(childHandler)) {
            childObserve[childTarget][childEvent] = childHandler.replace(' ', '').split(',');
          }
          if (!(parentObserve != null ? parentObserve[childTarget] : void 0)) {
            parentObserve[childTarget] = {};
          }
          if (!(parentObserve != null ? (_ref = parentObserve[childTarget]) != null ? _ref[childEvent] : void 0 : void 0)) {
            parentObserve[childTarget][childEvent] = childObserve[childTarget][childEvent];
            delete childObserve[childTarget][childEvent];
          }
        }
      }
      for (parentTarget in parentObserve) {
        parentEvents = parentObserve[parentTarget];
        for (parentEvent in parentEvents) {
          parentHandler = parentEvents[parentEvent];
          if (Ext.isString(parentHandler)) {
            parentObserve[parentTarget][parentEvent] = parentHandler.split(',');
          }
          if (childObserve != null ? (_ref1 = childObserve[parentTarget]) != null ? _ref1[parentEvent] : void 0 : void 0) {
            childHandlerArray = childObserve[parentTarget][parentEvent];
            parentHandlerArray = parentObserve[parentTarget][parentEvent];
            parentObserve[parentTarget][parentEvent] = Ext.Array.unique(Ext.Array.insert(parentHandlerArray, 0, childHandlerArray));
          }
        }
      }
      return parentObserve;
    },
<span id='Deft-mixin-Observer-static-method-convertConfigArray'>    /**
</span>    		* @private
    		* Converts an observe configuration that use an array of event configuration objects into object keys for
    		* event name, containing an array of configuration objects.
    */

    convertConfigArray: function(observeConfig, eventOptionNames) {
      var handlerConfig, newObserveEvents, observeEvents, observeTarget, thisEventOptionName, thisObserveEvent, _i, _j, _len, _len1, _results;
      _results = [];
      for (observeTarget in observeConfig) {
        observeEvents = observeConfig[observeTarget];
        if (Ext.isArray(observeEvents)) {
          newObserveEvents = {};
          for (_i = 0, _len = observeEvents.length; _i &lt; _len; _i++) {
            thisObserveEvent = observeEvents[_i];
            if (Ext.Object.getSize(thisObserveEvent) === 1) {
              Ext.apply(newObserveEvents, thisObserveEvent);
            } else {
              handlerConfig = {};
              if ((thisObserveEvent != null ? thisObserveEvent.fn : void 0) != null) {
                handlerConfig.fn = thisObserveEvent.fn;
              }
              if ((thisObserveEvent != null ? thisObserveEvent.scope : void 0) != null) {
                handlerConfig.scope = thisObserveEvent.scope;
              }
              for (_j = 0, _len1 = eventOptionNames.length; _j &lt; _len1; _j++) {
                thisEventOptionName = eventOptionNames[_j];
                if ((thisObserveEvent != null ? thisObserveEvent[thisEventOptionName] : void 0) != null) {
                  handlerConfig[thisEventOptionName] = thisObserveEvent[thisEventOptionName];
                }
              }
              newObserveEvents[thisObserveEvent.event] = [handlerConfig];
            }
          }
          _results.push(observeConfig[observeTarget] = newObserveEvents);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
<span id='Deft-mixin-Observer-static-method-afterMixinProcessed'>    /**
</span>    		@private
    */

    afterMixinProcessed: function(target) {
      target[this.MIXIN_COMPLETED_KEY] = true;
    }
  }
});
</pre>
</body>
</html>
