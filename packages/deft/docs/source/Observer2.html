<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

<span id='Deft-mvc-Observer'>/**
</span>* @private
* Used by Deft.mvc.ViewController to handle events fired from injected objects.
*/

Ext.define('Deft.mvc.Observer', {
  requires: ['Deft.core.Class', 'Ext.util.Observable', 'Deft.util.Function'],
<span id='Deft-mvc-Observer-method-constructor'>  /**
</span>  	* Expects a config object with properties for host, target, and events.
  */

  constructor: function(config) {
    var eventName, events, handler, handlerArray, host, options, references, scope, target, _i, _len;
    this.listeners = [];
    host = config != null ? config.host : void 0;
    target = config != null ? config.target : void 0;
    events = config != null ? config.events : void 0;
    if (host &amp;&amp; target &amp;&amp; (this.isPropertyChain(target) || this.isTargetObservable(host, target))) {
      for (eventName in events) {
        handlerArray = events[eventName];
        if (Ext.isString(handlerArray)) {
          handlerArray = handlerArray.replace(' ', '').split(',');
        }
        for (_i = 0, _len = handlerArray.length; _i &lt; _len; _i++) {
          handler = handlerArray[_i];
          scope = host;
          options = null;
          if (Ext.isObject(handler)) {
            options = Ext.clone(handler);
            if (options != null ? options.event : void 0) {
              eventName = this.extract(options, &quot;event&quot;);
            }
            if (options != null ? options.fn : void 0) {
              handler = this.extract(options, &quot;fn&quot;);
            }
            if (options != null ? options.scope : void 0) {
              scope = this.extract(options, &quot;scope&quot;);
            }
          }
          references = this.locateReferences(host, target, handler);
          if (references) {
            references.target.on(eventName, references.handler, scope, options);
            this.listeners.push({
              targetName: target,
              target: references.target,
              event: eventName,
              handler: references.handler,
              scope: scope
            });
            Deft.Logger.log(&quot;Created observer on '&quot; + target + &quot;' for event '&quot; + eventName + &quot;'.&quot;);
          } else {
            Deft.Logger.warn(&quot;Could not create observer on '&quot; + target + &quot;' for event '&quot; + eventName + &quot;'.&quot;);
          }
        }
      }
    } else {
      Deft.Logger.warn(&quot;Could not create observers on '&quot; + target + &quot;' because '&quot; + target + &quot;' is not an Ext.util.Observable&quot;);
    }
    return this;
  },
<span id='Deft-mvc-Observer-method-isTargetObservable'>  /**
</span>  	* Returns true if the passed host has a target that is Observable.
  	* Checks for an isObservable=true property, observable mixin, or if the class extends Observable.
  */

  isTargetObservable: function(host, target) {
    var hostTarget, hostTargetClass, _ref;
    hostTarget = this.locateTarget(host, target);
    if (hostTarget == null) {
      return false;
    }
    if ((hostTarget.isObservable != null) || (((_ref = hostTarget.mixins) != null ? _ref.observable : void 0) != null)) {
      return true;
    } else {
      hostTargetClass = Ext.ClassManager.getClass(hostTarget);
      return Deft.Class.extendsClass(hostTargetClass, 'Ext.util.Observable') || Deft.Class.extendsClass(hostTargetClass, 'Ext.mixin.Observable');
    }
  },
<span id='Deft-mvc-Observer-method-locateTarget'>  /**
</span>  	* Attempts to locate an observer target given the host object and target property name.
  	* Checks for both host[ target ], and host.getTarget().
  */

  locateTarget: function(host, target) {
    var result;
    if (Ext.isFunction(host['get' + Ext.String.capitalize(target)])) {
      result = host['get' + Ext.String.capitalize(target)].call(host);
      return result;
    } else if ((host != null ? host[target] : void 0) != null) {
      result = host[target];
      return result;
    } else {
      return null;
    }
  },
<span id='Deft-mvc-Observer-method-isPropertyChain'>  /**
</span>  	* Returns true if the passed target is a string containing a '.', indicating that it is referencing a nested property.
  */

  isPropertyChain: function(target) {
    return Ext.isString(target) &amp;&amp; target.indexOf('.') &gt; -1;
  },
<span id='Deft-mvc-Observer-method-locateReferences'>  /**
</span>  	* Given a host object, target property name, and handler, return object references for the final target and handler function.
  	* If necessary, recurse down a property chain to locate the final target object for the event listener.
  */

  locateReferences: function(host, target, handler) {
    var handlerHost, propertyChain;
    handlerHost = host;
    if (this.isPropertyChain(target)) {
      propertyChain = this.parsePropertyChain(host, target);
      if (!propertyChain) {
        return null;
      }
      host = propertyChain.host;
      target = propertyChain.target;
    }
    if (Ext.isFunction(handler)) {
      return {
        target: this.locateTarget(host, target),
        handler: handler
      };
    } else if (Ext.isFunction(handlerHost[handler])) {
      return {
        target: this.locateTarget(host, target),
        handler: handlerHost[handler]
      };
    } else {
      return null;
    }
  },
<span id='Deft-mvc-Observer-method-parsePropertyChain'>  /**
</span>  	* Given a target property chain and a property host object, recurse down the property chain and return
  	* the final host object from the property chain, and the final object that will accept the event listener.
  */

  parsePropertyChain: function(host, target) {
    var propertyChain;
    if (Ext.isString(target)) {
      propertyChain = target.split('.');
    } else if (Ext.isArray(target)) {
      propertyChain = target;
    } else {
      return null;
    }
    if (propertyChain.length &gt; 1 &amp;&amp; (this.locateTarget(host, propertyChain[0]) != null)) {
      return this.parsePropertyChain(this.locateTarget(host, propertyChain[0]), propertyChain.slice(1));
    } else if (this.isTargetObservable(host, propertyChain[0])) {
      return {
        host: host,
        target: propertyChain[0]
      };
    } else {
      return null;
    }
  },
<span id='Deft-mvc-Observer-method-extract'>  /**
</span>  	* Retrieves the value for the specified object key and removes the pair
  	* from the object.
  */

  extract: function(object, key) {
    var value;
    value = object[key];
    delete object[key];
    return value;
  },
<span id='Deft-mvc-Observer-method-destroy'>  /**
</span>  	* Iterate through the listeners array and remove each event listener.
  */

  destroy: function() {
    var listenerData, _i, _len, _ref;
    _ref = this.listeners;
    for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
      listenerData = _ref[_i];
      Deft.Logger.log(&quot;Removing observer on '&quot; + listenerData.targetName + &quot;' for event '&quot; + listenerData.event + &quot;'.&quot;);
      listenerData.target.un(listenerData.event, listenerData.handler, listenerData.scope);
    }
    this.listeners = [];
  }
});
</pre>
</body>
</html>
